package table

import "errors"

// QueryRowsWithForeignKeys retrieves rows from the table based on given conditions including foreign key matches
func (t *Table) QueryRowsWithForeignKeys(conditions map[string]interface{}, registry *TableRegistry) ([]Row, error) {
	if len(conditions) == 0 {
		return t.queryAllRowsWithForeignKeys(registry)
	}

	columnName, columnNameExists := conditions["columnName"].(string)
	value, valueExists := conditions["value"]

	if !columnNameExists || !valueExists {
		return nil, errors.New("columnName or value is missing")
	}

	var matchedRows []Row

	for _, row := range t.Metadata.Rows {
		if val, ok := row.Data[columnName]; ok && val == value {
			matchedRows = append(matchedRows, row)
			matchedRows = t.fetchRelatedRows(row, registry, matchedRows)
		}
	}

	if len(matchedRows) == 0 {
		return nil, errors.New("no matching rows found")
	}
	return matchedRows, nil
}

// queryAllRowsWithForeignKeys retrieves all rows from the table including foreign key matches
func (t *Table) queryAllRowsWithForeignKeys(registry *TableRegistry) ([]Row, error) {
	var allRows []Row
	for _, row := range t.Metadata.Rows {
		allRows = append(allRows, row)
		allRows = t.fetchRelatedRows(row, registry, allRows)
	}
	return allRows, nil
}

// fetchRelatedRows fetches related rows from referenced tables based on foreign key constraints
func (t *Table) fetchRelatedRows(row Row, registry *TableRegistry, matchedRows []Row) []Row {
	for _, fk := range t.Metadata.ForeignKeys {
		referencedTable := registry.getReferencedTable(fk.RefTable)
		if referencedTable == nil {
			continue
		}
		referencedConditions := CreateQueryConditions(
			map[string]interface{}{"columnName": fk.RefColumns[0], "value": row.Data[fk.Columns[0]]},
		)
		matchedRefRows, err := referencedTable.QueryRows(referencedConditions)
		if err == nil {
			matchedRows = append(matchedRows, matchedRefRows...)
		}
	}
	return matchedRows
}