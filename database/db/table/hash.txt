package table

import (
	"errors"
	"fmt"
)

// CreateHashIndex creates a hash index on the specified column
func (t *Table) CreateHashIndex(columnName string) error {
	if _, ok := t.IndexTable[columnName]; ok {
		return errors.New("index already exists for column: " + columnName)
	}
	t.IndexTable[columnName] = NewHashTable()
	return nil
}

// InsertIntoIndex inserts data into the specified index of the hash table
func (t *Table) InsertIntoIndex(indexName string, key []interface{}, value interface{}) error {
	index, ok := t.IndexTable[indexName]
	if !ok {
		return errors.New("index not found: " + indexName)
	}
	return index.Insert(key, value)
}

func NewHashTable() *HashTable {
	return &HashTable{
		Data: make(map[string]interface{}),
	}
}

// Insert inserts a key-value pair into the hash table
func (ht *HashTable) Insert(key []interface{}, value interface{}) error {
	// Convert key to string for simplicity (assuming key is a single value)
	strKey := fmt.Sprintf("%v", key[0])
	ht.Data[strKey] = value
	return nil
}

// Search searches for a key in the hash table and returns the corresponding value
func (ht *HashTable) Search(key []interface{}) ([]interface{}, error) {
	strKey := fmt.Sprintf("%v", key[0])
	if val, ok := ht.Data[strKey]; ok {
		return []interface{}{val}, nil
	}
	return nil, errors.New("key not found")
}